\chapter{Proposta}
  \capepigrafe[0.5\textwidth]{``Mais sofreu a mãe do porco espinho.''}{Pai, Meu}

  Nossa proposta é apresentar uma abordagem para a construção de \textit{software}
  escaláveis incentivando o descobrimento e o aprendizado de erros e com atenção na
  disponibilidade do sistema. Acreditamos que um produto escalável e uma equipe
  que se preocupe em aprender com erros e manter o sistema sempre disponível,
  é capaz de criar produtos de alta qualidade e grande sucesso. \newline
  Como já é apresentado na Engenharia de Confiabilidade do Google ([*]), devemos
  esquecer a cultura de culpar as pessoas por erros cometidos e adquirir uma
  cultura de aprendizado, utilizar do erro para entender como ele ocorreu e assim
  produzir um produto com maior qualidade e adquirir o conhecimento para que o
  erro não ocorra novamente ou ocorra em outros produtos. Mas, adquirir essa
  maturidade e esse \textit{mindset} é um processo, não é algo imediato, e é
  necessário entender em qual momento está a equipe e como implementar estes
  processos. \newline
  De acordo com o The DevOps Handbook ([*]), esse processo de transformação é
  divido em três partes, o fluxo, \textit{feedback} e, aprendizado continuo e
  experimentação. A primeira parte é sobre definirmos o nosso fluxo de trabalho,
  os nossos processos e com isso automatiza-los, com a criação do \textit{pipeline},
  realização de testes automatizados, estruturação da arquitetura do \textit{software}
  e conseguindo realizar entregas de baixo risco. A segunda parte é adquirir a
  prática do \textit{feedback}, cujo objetivo é o de aprender com os nossos erros,
  tentar solucionar o mais rápido possível e logo após, realizar uma reunião com
  todos os envolvidos e interessados para adquirir entender o que ocorreu, quais
  foram as medidas tomadas e o que fazer para não ocorrer novamente, sempre
  lembrando que o objetivo não é encontrar um culpado, mas sim aprender com o
  ocorrido. Outro fator importante é o de investir tempo em melhorar a telemtria
  que temos sobre o sistema, trabalhar em quais informações precisamos para
  supervisionar o funcionamento do sistema e evitarmos que problemas ocorram,
  como por exemplo, manter o controle da performance de cada servidor utilizado
  para o funcionamento da aplicação, quando um deles estiver com o nível de
  processamento abaixo do esperado, podemos analisar se ele não está sendo
  aproveitado, e assim realocar recursos para melhorar o desempenho do sistema,
  ou se ele está apresentando sinais de mau funcionamento. A terceira parte é o
  de aprendizado continuo e experimentação, ela nos incentiva a realizar
  experimentos no nosso produto afim de adapta-lo e gerarmos conhecimento para o
  negócio, um exemplo de experimento, unificar três telas em uma só e vêr como o
  usuário reage a esta mudança, dependendo do resultado, podemos aumentar a
  produtividade do usuário no sistema, ou descobrir que ele isso o deixou mais
  confuso, em ambos os casos aprendemos sobre o comportamento do nosso usuário e
  isso pode ser utilizado para futuras demandas e resoluções de erros. Outro ponto
  importante sobre essa parte é a de gerar conhecimento, assim que algo é
  descoberto, devemos apresentar para todos do time e caso seja algo que possa
  ser utilizados em outros projetos, escalar esse aprendizado para a empresa,
  onde devemos considerar que devemos demonstrar todo tipo de conhecimento, seja
  uma descoberta comportamental do usuário, a resolução de algum defeito, um erro
  cometido durante o projeto, qualquer aprendisado deve ser levado em consideração
  e, devido a isso, não podemos culpar as pessoas por erros cometidos. Quando
  culpamos alguém, inibimos a pessoa de demonstrar o erro, consequentemente,
  perdemos uma importante fonte de aprendizagem, desta forma, perdemos a oportunidade
  de melhorarmos nosso produto, nossa equipe e nosso trabalho. \newline
  Um dos problemas mais urgentes em nosso sistema e que precisamos procurar evitar
  o máximo possível são os de disponibilidade. Um sistema que não está disponível,
  perde credibilidade, o negócio é impactado de forma direta e os usuários que
  necessitam dele, acabam se estressando por não poder fazer nada. Lidar com a
  disponibilidade do sistema está diretamente relacionada com assumir riscos,
  entender que haverá momentos críticos no sistema que precisamos nos preparar e
  que sempre há a chance de falharmos e do sistema cair. Precisamos através das
  necessidades do negócio e da utilização do usuário aprender como podemos manter
  a disponibilidade. Primeiramente, disponibilidade não pode ser considerado
  simplesmente como "no ar ou fora do ar", uma funcionalidade que demore para ser
  executada, pode motivar o usuário a não utiliza-la, o que prova que ela não está
  disponível, vamos supor, que estamos em um sistema que sejam realizdas negociações,
  o usuário está negociando com um cliente e propõe um desconto para o produto que
  ele está tentando vender, nosso sistema tem uma função de simulação de desconto,
  então nosso vendedor logo tenta simular, porem, como é um produto grande, essa
  simulação está sendo processada já a cinco minutos, e o cliente já está cansado
  de esperar, como o ele não teve a simulação em tempo hábil e o vendedor dependia
  desse valor para continuar a negociação, decidiram continuar a conversa outro dia,
  já com o valor em mãos. Após este episódio, nosso vendedor perdeu a confiança
  no sistema e decidiu não mais utilizar a funcionalidade de negociação, embora a
  simulação tenha funcionado muito bem para produtos pequenos, quando o nosso
  vendedor mais precisou, ele não atendeu as expectivas. Cinco minutos foi o
  suficiente para indisponibilizar essa funcionalidade para esse usuário, que
  como está aborrecido, vai passar esta frustração para outros usuários. Se não
  tivermos a informação de que há este problema no sistema, seja por \textit{feedback}
  ou por alguma métrica, jamais saberemos deste erro e com o passar do tempo
  esta funcionalidade será esquecida. \newline
  Outro ponto a ser considerado é o preço do \textit{software}, podemos manter
  nosso sistema sempre disponível se tivermos uma grande quantidade de servidores,
  armazenamento infinito, e vário dominios de redundancia, o custo para manter
  todos esses recursos é inviável, precisamos sempre controlar o que o sistema
  precisa e o que a empresa pode pagar. Controlar os custos é uma tarefa
  desafiadora, precisamos ver o qual o retorno que estamos recebendo com a aplicação
  e quais são os riscos que podemos enfrentar. Não adaianta montar um sistema
  indestrutível se ele não gera valor para o negócio, e não adianta deixar o
  sistema vulnerável para controlar custos, a queda de um produto deve ser
  considerado como uma descredibilidade da empresa, pois é uma se torna um
  simbolo de falta de qualidade. O meio termo seria montar um produto escalável,
  conseguir controlar o quanto de recurso disponibilizar, saber quais são as
  épocas em que precisamos do sistema funcionando, quais são as funcionalidades
  mais críticas e quais riscos podemos aceitar. Tomar as nossas decisões com
  base nos riscos, nos dá segurança e preparo para as mais adversas situações,
  como planejamos que pode acontecer erros, conseguimos nos antecipar e solucionar
  o mais rápido possível, gerando pouco impacto para o negócio. Sabendo onde estão
  os pontos fracos do nosso produto, podemos prever que um problema ocorra antes
  que ele aconteça, e acompanhando as métricas diariamente, quando os primeiros
  sinais de que vai ocorrer um erro, podemos reavaliar os riscos e assumir uma
  postura de mitigação ou solução. Admitindo que nosso produto não é perfeito e
  aceitando falhas, podemos trabalhar na melhora continua. Com a possibilidade
  de controlar os riscos, podemos investir financeiramente conforme a necessidade
  do negócio, muitas vezes é mais viável comunicar que determinada funcionalidade
  vai para de funcionar por um período, do que realocar recursos para manter em
  funcionamento.

    \section{Como adquirir escalabilidade?}

    \section{Como manter o sistema disponível?}

    \section{Como identificar falhas?}

      \subsection{O que fazer com as falhas identificadas?}
